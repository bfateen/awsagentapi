AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'Combined template for Serverless RAG Q&A application using Knowledge Base, Agents, OpenSearch Serverless, and Vector Index creation'

Parameters:
  IAMUserArn: 
    Description: The ARN of the IAM user (or assumed role) running this CloudFormation template.
    Type: String

  AOSSCollectionName:
    Description: Name of the Amazon OpenSearch Service Serverless (AOSS) collection.
    Default: rag-bedrock-kb
    Type: String
    MinLength: 1
    MaxLength: 21
    AllowedPattern: ^[a-z0-9](-*[a-z0-9])*
    ConstraintDescription: Must be lowercase or numbers with a length of 1-63 characters.

  AOSSIndexName:
    Description: Name of the vector index in the Amazon OpenSearch Service Serverless (AOSS) collection.
    Default: rag-bedrock-readthedocs-io
    Type: String

  KnowledgeBaseName:
    Default: rag-bedrock-kb
    Type: String
    Description: The name of the knowledge base.

  KnowledgeBaseDescription:
    Default: Answer based only on information contained in knowledge base. 
    Type: String
    Description: The description of the knowledge base.

  AgentName:
    Default: rag-bedrock-agent
    Type: String
    Description: The name of the agent.

Resources:
  # Resources from the first template
  S3Bucket:
    Type: AWS::S3::Bucket
    Description: Creates an Amazon S3 bucket to hold source data for the knowledge base.
    Properties:
      BucketName: !Join
        - '-'
        - - !Ref AOSSCollectionName
          - !Sub ${AWS::AccountId}
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  AmazonBedrockExecutionRoleForKnowledgeBase:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - '-'
        - - AmazonBedrockExecutionRoleForKnowledgeBase
          - !Ref AOSSCollectionName
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                "aws:SourceAccount": !Sub "${AWS::AccountId}"
              ArnLike:
                "AWS:SourceArn": !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
      Path: /
      Policies:
        - PolicyName: S3ReadOnlyAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:Get*
                  - s3:List*
                  - s3-object-lambda:Get*
                  - s3-object-lambda:List*
                Resource:
                  - !Sub arn:aws:s3:::${S3Bucket}
                  - !Sub arn:aws:s3:::${S3Bucket}/*
        - PolicyName: AOSSAPIAccessAll
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - aoss:APIAccessAll
                Resource: !Sub arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/*
        - PolicyName: BedrockListAndInvokeModel
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:ListCustomModels
                Resource: '*'
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                Resource: !Sub arn:aws:bedrock:${AWS::Region}::foundation-model/*

  DeleteS3Bucket:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Description: "Delete all objects in S3 bucket"
      Timeout: 30
      Role: !GetAtt 'LambdaBasicExecutionRole.Arn'
      Runtime: python3.9
      Environment:
        Variables:
          BUCKET_NAME: !Ref S3Bucket
      Code:
        ZipFile: |
          import json, boto3, logging
          import cfnresponse
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info("event: {}".format(event))
              try:
                  bucket = event['ResourceProperties']['BucketName']
                  logger.info("bucket: {}, event['RequestType']: {}".format(bucket,event['RequestType']))
                  if event['RequestType'] == 'Delete':
                      s3 = boto3.resource('s3')
                      bucket = s3.Bucket(bucket)
                      for obj in bucket.objects.filter():
                          logger.info("delete obj: {}".format(obj))
                          s3.Object(bucket.name, obj.key).delete()

                  sendResponseCfn(event, context, cfnresponse.SUCCESS)
              except Exception as e:
                  logger.info("Exception: {}".format(e))
                  sendResponseCfn(event, context, cfnresponse.FAILED)

          def sendResponseCfn(event, context, responseStatus):
              responseData = {}
              responseData['Data'] = {}
              cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")   

  LambdaBasicExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - !Sub arn:aws:s3:::${S3Bucket}
                  - !Sub arn:aws:s3:::${S3Bucket}/*

  DataAccessPolicy:
    Type: 'AWS::OpenSearchServerless::AccessPolicy'
    Properties:
      Name: 'instantagent-access-policy2'
      Type: data
      Description: Access policy for the AOSS collection
      Policy: !Sub >-
        [{"Description":"Access for cfn user","Rules":[{"ResourceType":"index","Resource":["index/${AOSSCollectionName}/*"],"Permission":[
                    "aoss:CreateIndex",
                    "aoss:UpdateIndex",
                    "aoss:DescribeIndex",
                    "aoss:ReadDocument",
                    "aoss:WriteDocument"
                  ]},
        {"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"],"Permission":["aoss:*"]}],
        "Principal":["${IAMUserArn}", "${AmazonBedrockExecutionRoleForKnowledgeBase.Arn}", "${LambdaExecutionRole.Arn}"]}]

  Collection:
    Type: 'AWS::OpenSearchServerless::Collection'
    Properties:
      Name: !Ref AOSSCollectionName
      Type: VECTORSEARCH
      StandbyReplicas: DISABLED
      Description: Collection to hold vector search data
    DependsOn: EncryptionPolicy

  NetworkPolicy:
    Type: 'AWS::OpenSearchServerless::SecurityPolicy'
    Properties:
      Name: !Join
        - '-'
        - - !Ref AOSSCollectionName
          - net-policy2
      Type: network
      Description: Network policy for the AOSS collection
      Policy: !Sub >-
        [{"Rules":[{"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"]}, {"ResourceType":"dashboard","Resource":["collection/${AOSSCollectionName}"]}],"AllowFromPublic":true}]

  EncryptionPolicy:
    Type: 'AWS::OpenSearchServerless::SecurityPolicy'
    Properties:
      Name: !Join
        - '-'
        - - !Ref AOSSCollectionName
          - security-policy2
      Type: encryption
      Description: Encryption policy for the AOSS collection
      Policy: !Sub >-
        {"Rules":[{"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"]}],"AWSOwnedKey":true}

  VectorIndexUpdate:
    Type: Custom::OpenSearchServerlessVectorIndex
    Properties:
      ServiceToken: !GetAtt OpenSearchVectorIndexLambda.Arn
      CollectionName: !Ref AOSSCollectionName
      IndexName: !Ref AOSSIndexName
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    DependsOn: Collection

  OpenSearchVectorIndexLambda:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import os
          import sys
          import subprocess
          import json
          import traceback
          import boto3
          import urllib3
          import logging
          import base64
          import time
          import random
          import string
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def install_and_import_dependencies():
              subprocess.check_call([sys.executable, "-m", "pip", "install", "--target", "/tmp", "requests", "requests_aws4auth"])
              sys.path.append('/tmp')
              global requests, AWS4Auth
              import requests
              from requests_aws4auth import AWS4Auth
              logger.info("Dependencies installed and imported successfully")

          def generate_policy_version():
              timestamp = int(time.time())
              random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
              version_string = f"{timestamp}-{random_string}"
              return base64.b64encode(version_string.encode()).decode().rstrip('=')

          def send_cfn_response(event, context, response_status, response_data, physical_resource_id=None, reason=None):
              response_url = event['ResponseURL']
              logger.info(f"CFN response URL: {response_url}")

              response_body = {
                  'Status': response_status,
                  'Reason': reason or f"See the details in CloudWatch Log Stream: {context.log_stream_name}",
                  'PhysicalResourceId': physical_resource_id or context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'NoEcho': False,
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)
              logger.info(f"CFN response body: {json_response_body}")

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              try:
                  http = urllib3.PoolManager()
                  response = http.request('PUT', response_url, headers=headers, body=json_response_body)
                  logger.info(f"CFN response status code: {response.status}")
              except Exception as e:
                  logger.error(f"Error sending CFN response: {str(e)}")

          def handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")
              
              try:
                  install_and_import_dependencies()

                  region = os.environ['AWS_REGION']
                  service = 'aoss'
                  credentials = boto3.Session().get_credentials()
                  awsauth = AWS4Auth(credentials.access_key, credentials.secret_key, region, service, session_token=credentials.token)
                  
                  collection_name = event['ResourceProperties']['CollectionName']
                  index_name = event['ResourceProperties']['IndexName']
                  
                  client = boto3.client('opensearchserverless')
                  
                  logger.info(f"Attempting to get collection details for {collection_name}")
                  collection_data = client.batch_get_collection(names=[collection_name])['collectionDetails'][0]
                  collection_endpoint = collection_data['collectionEndpoint']
                  
                  logger.info(f"Collection endpoint: {collection_endpoint}")
                  logger.info("Going to sleep")
                  time.sleep(30)
                  logger.info("Woke up")

                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      create_vector_index(collection_endpoint, index_name, awsauth)
                  elif event['RequestType'] == 'Delete':
                      delete_index(collection_endpoint, index_name, awsauth)
                  
                  send_cfn_response(event, context, 'SUCCESS', {"message": "Operation completed successfully"})
              except Exception as e:
                  logger.error(f"Error occurred: {str(e)}")
                  logger.error(f"Traceback: {traceback.format_exc()}")
                  send_cfn_response(event, context, 'FAILED', {"error": str(e)})

          def create_vector_index(endpoint, index_name, awsauth):
              url = f'{endpoint}/{index_name}'
              
              index_body = {
                  "settings": {
                      "index.knn": True
                  },
                  "mappings": {
                      "properties": {
                          "vector": {
                              "type": "knn_vector",
                              "dimension": 1536,
                              "method": {
                                  "name": "hnsw",
                                  "space_type": "l2",
                                  "engine": "faiss"
                              }
                          }
                      }
                  }
              }

              headers = {"Content-Type": "application/json"}
              
              logger.info(f"Attempting to create index {index_name}")
              logger.info(f"Request URL: {url}")
              logger.info(f"Request body: {json.dumps(index_body)}")
              
              try:
                  response = requests.put(url, auth=awsauth, json=index_body, headers=headers)
                  logger.info(f"Index creation response status: {response.status_code}")
                  logger.info(f"Index creation response body: {response.text}")
                  response.raise_for_status()
              except requests.exceptions.RequestException as e:
                  logger.error(f"Request failed: {e}")
                  if hasattr(e, 'response'):
                      logger.error(f"Response status code: {e.response.status_code}")