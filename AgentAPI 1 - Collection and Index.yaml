AWSTemplateFormatVersion: '2010-09-09'
Transform: AWS::Serverless-2016-10-31
Description: 'Combined template for Serverless RAG Q&A application using Knowledge Base, Agents, OpenSearch Serverless, and Vector Index creation'

Parameters:
  IAMUserArn: 
    Description: The ARN of the IAM user (or assumed role) running this CloudFormation template.
    Type: String

  AOSSCollectionName:
    Description: Name of the Amazon OpenSearch Service Serverless (AOSS) collection.
    Default: inagent-kb
    Type: String
    MinLength: 1
    MaxLength: 21
    AllowedPattern: ^[a-z0-9](-*[a-z0-9])*
    ConstraintDescription: Must be lowercase or numbers with a length of 1-63 characters.

  AOSSIndexName:
    Description: Name of the vector index in the Amazon OpenSearch Service Serverless (AOSS) collection.
    Default: inagent-io
    Type: String

Resources:
  # Resources from the first template
  S3Bucket:
    Type: AWS::S3::Bucket
    Description: Creates an Amazon S3 bucket to hold source data for the knowledge base.
    Properties:
      BucketName: !Join
        - '-'
        - - !Ref AOSSCollectionName
          - !Sub ${AWS::AccountId}
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256

  AmazonBedrockExecutionRoleForKnowledgeBase:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Join
        - '-'
        - - AmazonBedrockExecutionRoleForKnowledgeBase
          - !Ref AOSSCollectionName
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - bedrock.amazonaws.com
                - aoss.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                "aws:SourceAccount": !Sub "${AWS::AccountId}"
              ArnLike:
                "AWS:SourceArn": !Sub "arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*"
      Path: /
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonBedrockFullAccess
      Policies:
        - PolicyName: S3ReadOnlyAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:Get*
                  - s3:List*
                  - s3-object-lambda:Get*
                  - s3-object-lambda:List*
                Resource:
                  - !Sub arn:aws:s3:::${S3Bucket}
                  - !Sub arn:aws:s3:::${S3Bucket}/*
        - PolicyName: AOSSAPIAccessAll
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - aoss:APIAccessAll
                Resource: !Sub arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/*
        - PolicyName: BedrockListAndInvokeModel
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:ListCustomModels
                  - bedrock:InvokeModel
                Resource: '*'
        - PolicyName: OpenSearchServerlessAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: 
                  - aoss:CreateCollection
                  - aoss:DeleteCollection
                  - aoss:CreateAccessPolicy
                  - aoss:CreateSecurityPolicy
                  - aoss:GetAccessPolicy
                  - aoss:UpdateAccessPolicy
                  - aoss:BatchGetCollection
                  - aoss:CreateIndex
                  - aoss:DeleteIndex
                  - aoss:UpdateIndex
                Resource: '*'

  DeleteS3Bucket:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Description: "Delete all objects in S3 bucket"
      Timeout: 30
      Role: !GetAtt 'LambdaBasicExecutionRole.Arn'
      Runtime: python3.9
      Environment:
        Variables:
          BUCKET_NAME: !Ref S3Bucket
      Code:
        ZipFile: |
          import json, boto3, logging
          import cfnresponse
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info("event: {}".format(event))
              try:
                  bucket = event['ResourceProperties']['BucketName']
                  logger.info("bucket: {}, event['RequestType']: {}".format(bucket,event['RequestType']))
                  if event['RequestType'] == 'Delete':
                      s3 = boto3.resource('s3')
                      bucket = s3.Bucket(bucket)
                      for obj in bucket.objects.filter():
                          logger.info("delete obj: {}".format(obj))
                          s3.Object(bucket.name, obj.key).delete()

                  sendResponseCfn(event, context, cfnresponse.SUCCESS)
              except Exception as e:
                  logger.info("Exception: {}".format(e))
                  sendResponseCfn(event, context, cfnresponse.FAILED)

          def sendResponseCfn(event, context, responseStatus):
              responseData = {}
              responseData['Data'] = {}
              cfnresponse.send(event, context, responseStatus, responseData, "CustomResourcePhysicalID")   

  LambdaBasicExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: arn:aws:logs:*:*:*
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - !Sub arn:aws:s3:::${S3Bucket}
                  - !Sub arn:aws:s3:::${S3Bucket}/*

  DataAccessPolicy:
    Type: 'AWS::OpenSearchServerless::AccessPolicy'
    Properties:
      Name: 'instantagent-access-policy3'
      Type: data
      Description: Access policy for the AOSS collection
      Policy: !Sub >-
        [{"Description":"Access for cfn user","Rules":[{"ResourceType":"index","Resource":["index/${AOSSCollectionName}/*"],"Permission":[
                    "aoss:CreateIndex",
                    "aoss:UpdateIndex",
                    "aoss:DescribeIndex",
                    "aoss:ReadDocument",
                    "aoss:WriteDocument"
                  ]},
        {"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"],"Permission":["aoss:*"]}],
        "Principal":["${IAMUserArn}", "${AmazonBedrockExecutionRoleForKnowledgeBase.Arn}", "${LambdaExecutionRole.Arn}"]}]
    DependsOn: AmazonBedrockExecutionRoleForKnowledgeBase 

  Collection:
    Type: 'AWS::OpenSearchServerless::Collection'
    Properties:
      Name: !Ref AOSSCollectionName
      Type: VECTORSEARCH
      StandbyReplicas: DISABLED
      Description: Collection to hold vector search data
    DependsOn: EncryptionPolicy

  NetworkPolicy:
    Type: 'AWS::OpenSearchServerless::SecurityPolicy'
    Properties:
      Name: !Join
        - '-'
        - - !Ref AOSSCollectionName
          - net-policy3
      Type: network
      Description: Network policy for the AOSS collection
      Policy: !Sub >-
        [{"Rules":[{"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"]}, {"ResourceType":"dashboard","Resource":["collection/${AOSSCollectionName}"]}],"AllowFromPublic":true}]

  EncryptionPolicy:
    Type: 'AWS::OpenSearchServerless::SecurityPolicy'
    Properties:
      Name: !Join
        - '-'
        - - !Ref AOSSCollectionName
          - security-policy3
      Type: encryption
      Description: Encryption policy for the AOSS collection
      Policy: !Sub >-
        {"Rules":[{"ResourceType":"collection","Resource":["collection/${AOSSCollectionName}"]}],"AWSOwnedKey":true}

  VectorIndexUpdate:
    Type: Custom::OpenSearchServerlessVectorIndex
    Properties:
      ServiceToken: !GetAtt OpenSearchVectorIndexLambda.Arn
      CollectionName: !Ref AOSSCollectionName
      IndexName: !Ref AOSSIndexName
    UpdateReplacePolicy: Retain
    DeletionPolicy: Retain
    DependsOn: Collection

  OpenSearchVectorIndexLambda:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import os
          import sys
          import subprocess
          import json
          import traceback
          import boto3
          import urllib3
          import logging
          import base64
          import time
          import random
          import string
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def install_and_import_dependencies():
              subprocess.check_call([sys.executable, "-m", "pip", "install", "--target", "/tmp", "requests", "requests_aws4auth"])
              sys.path.append('/tmp')
              global requests, AWS4Auth
              import requests
              from requests_aws4auth import AWS4Auth
              logger.info("Dependencies installed and imported successfully")

          def generate_policy_version():
              timestamp = int(time.time())
              random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
              version_string = f"{timestamp}-{random_string}"
              return base64.b64encode(version_string.encode()).decode().rstrip('=')

          def send_cfn_response(event, context, response_status, response_data, physical_resource_id=None, reason=None):
              response_url = event['ResponseURL']
              logger.info(f"CFN response URL: {response_url}")

              response_body = {
                  'Status': response_status,
                  'Reason': reason or f"See the details in CloudWatch Log Stream: {context.log_stream_name}",
                  'PhysicalResourceId': physical_resource_id or context.log_stream_name,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'NoEcho': False,
                  'Data': response_data
              }

              json_response_body = json.dumps(response_body)
              logger.info(f"CFN response body: {json_response_body}")

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              try:
                  http = urllib3.PoolManager()
                  response = http.request('PUT', response_url, headers=headers, body=json_response_body)
                  logger.info(f"CFN response status code: {response.status}")
              except Exception as e:
                  logger.error(f"Error sending CFN response: {str(e)}")

          def handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")
              
              try:
                  install_and_import_dependencies()

                  region = os.environ['AWS_REGION']
                  service = 'aoss'
                  credentials = boto3.Session().get_credentials()
                  awsauth = AWS4Auth(credentials.access_key, credentials.secret_key, region, service, session_token=credentials.token)
                  
                  collection_name = event['ResourceProperties']['CollectionName']
                  index_name = event['ResourceProperties']['IndexName']
                  
                  client = boto3.client('opensearchserverless')
                  
                  logger.info(f"Attempting to get collection details for {collection_name}")
                  collection_data = client.batch_get_collection(names=[collection_name])['collectionDetails'][0]
                  collection_endpoint = collection_data['collectionEndpoint']
                  
                  logger.info(f"Collection endpoint: {collection_endpoint}")
                  

                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      logger.info("Going to sleep")
                      time.sleep(120)
                      logger.info("Woke up")
                      create_vector_index(collection_endpoint, index_name, awsauth)
                      time.sleep(30)
                  elif event['RequestType'] == 'Delete':
                      delete_index(collection_endpoint, index_name, awsauth)
                  
                  

                  send_cfn_response(event, context, 'SUCCESS', {"message": "Operation completed successfully"})
              except Exception as e:
                  logger.error(f"Error occurred: {str(e)}")
                  logger.error(f"Traceback: {traceback.format_exc()}")
                  send_cfn_response(event, context, 'FAILED', {"error": str(e)})

          def create_vector_index(endpoint, index_name, awsauth):
              url = f'{endpoint}/{index_name}'
              
              index_body = {
                  "settings": {
                      "index.knn": True
                  },
                  "mappings": {
                      "properties": {
                          "vector": {
                              "type": "knn_vector",
                              "dimension": 1536,
                              "method": {
                                  "name": "hnsw",
                                  "space_type": "l2",
                                  "engine": "faiss"
                              }
                          }
                      }
                  }
              }

              headers = {"Content-Type": "application/json"}
              
              logger.info(f"Attempting to create index {index_name}")
              logger.info(f"Request URL: {url}")
              logger.info(f"Request body: {json.dumps(index_body)}")
              
              try:
                  response = requests.put(url, auth=awsauth, json=index_body, headers=headers)
                  logger.info(f"Index creation response status: {response.status_code}")
                  logger.info(f"Index creation response body: {response.text}")
                  response.raise_for_status()
              except requests.exceptions.RequestException as e:
                  logger.error(f"Request failed: {e}")
                  if hasattr(e, 'response'):
                      logger.error(f"Response status code: {e.response.status_code}")
                      logger.error(f"Response body: {e.response.text}")
                  raise

          def delete_index(endpoint, index_name, awsauth):
              url = f'{endpoint}/{index_name}'
              logger.info(f"Attempting to delete index {index_name}")
              logger.info(f"Request URL: {url}")
              try:
                  response = requests.delete(url, auth=awsauth)
                  logger.info(f"Index deletion response status: {response.status_code}")
                  logger.info(f"Index deletion response body: {response.text}")
                  if response.status_code != 404:  # Ignore 404 errors on delete
                      response.raise_for_status()
              except requests.exceptions.RequestException as e:
                  logger.error(f"Request failed: {e}")
                  if hasattr(e, 'response'):
                      logger.error(f"Response status code: {e.response.status_code}")
                      logger.error(f"Response body: {e.response.text}")
                  if response.status_code != 404:  # Ignore 404 errors on delete
                      raise

      Runtime: python3.8
      Timeout: 300
      MemorySize: 256

  OpenSearchServerlessCollectionPolicyAttachment:
    Type: Custom::OpenSearchServerlessCollectionPolicyAttachment
    Properties:
      ServiceToken: !GetAtt AttachPolicyLambda.Arn
      CollectionName: !Ref AOSSCollectionName
      PolicyName: !Ref DataAccessPolicy
      IAMRoleArn: !GetAtt LambdaExecutionRole.Arn
      KBRoleArn: !GetAtt AmazonBedrockExecutionRoleForKnowledgeBase.Arn
      IAMUserArn: !Ref IAMUserArn
    DependsOn: 
      - Collection
      - DataAccessPolicy

  AttachPolicyLambda:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json
          import traceback
          import time
          import random
          import string
          import base64

          def generate_policy_version():
              timestamp = int(time.time())
              random_string = ''.join(random.choices(string.ascii_lowercase + string.digits, k=10))
              version_string = f"{timestamp}-{random_string}"
              return base64.b64encode(version_string.encode()).decode().rstrip('=')

          def handler(event, context):
              client = boto3.client('opensearchserverless')
              
              try:
                  print(f"Received event: {json.dumps(event)}")
                  
                  if event['RequestType'] in ['Create', 'Update']:
                      policy_name = 'instantagent-access-policy3' #event['ResourceProperties']['PolicyName']
                      collection_name = event['ResourceProperties']['CollectionName']
                      iam_role_arn = event['ResourceProperties']['IAMRoleArn']
                      kb_role_arn = event['ResourceProperties']['KBRoleArn']
                      user_role_arn = event['ResourceProperties']['IAMUserArn']

                      # Generate a new policy version
                      policy_version = generate_policy_version()
                      print(f"Generated policy version: {policy_version}")

                      print(f"IAM Role ARN: {iam_role_arn}")
                      # Get the latest policy to avoid version conflicts
                      existing_policy = client.get_access_policy(name=policy_name, type='data')
                      print(f"existing Policy content: {json.dumps(existing_policy)}")

                      latest_version = existing_policy['accessPolicyDetail']['policyVersion']

                      print(f"Latest policy version: {latest_version}")

                      # Define the policy
                      policy = [{
                          "Rules": [{
                              "ResourceType": "collection",
                              "Resource": [f"collection/{collection_name}"],
                              "Permission": ["aoss:*"]
                          },
                          {
                              "ResourceType": "index",
                              "Resource": [f"index/{collection_name}/*"],
                              "Permission": [
                                "aoss:CreateIndex",
                                "aoss:UpdateIndex",
                                "aoss:DescribeIndex",
                                "aoss:ReadDocument",
                                "aoss:WriteDocument",
                                "aoss:*"
                            ]
                          }],
                          "Principal": [iam_role_arn,kb_role_arn,user_role_arn]
                      }]
                      
                      print(f"Updating policy: {policy_name}")
                      print(f"Policy content: {json.dumps(policy)}")
                      
                      # Update the policy
                      response = client.update_access_policy(
                          name=policy_name,
                          type='data',
                          description='Updated by CloudFormation',
                          policy=json.dumps(policy),
                          policyVersion=latest_version
                      )
                      
                      print(f"Update policy response: {json.dumps(response)}")
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  print(f"Error: {str(e)}")
                  print(f"Traceback: {traceback.format_exc()}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {"Error": str(e)})

      Runtime: python3.8
      Timeout: 60
      MemorySize: 128

  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: OpenSearchServerlessAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: 
                  - 'aoss:UpdateAccessPolicy'
                  - 'aoss:CreateAccessPolicy'
                  - 'aoss:GetAccessPolicy'
                  - 'aoss:BatchGetCollection'
                  - 'aoss:APIAccessAll'
                  - 'aoss:ListCollections'
                  - 'aoss:DescribeCollection'
                Resource: '*'
              - Effect: Allow
                Action:
                  - 'aoss:CreateIndex'
                  - 'aoss:UpdateIndex'
                  - 'aoss:DescribeIndex'
                  - 'aoss:ReadDocument'
                  - 'aoss:WriteDocument'
                Resource: !Sub 'arn:aws:aoss:${AWS::Region}:${AWS::AccountId}:collection/${AOSSCollectionName}'

  

Outputs:
  S3Bucket:
    Value: !GetAtt S3Bucket.Arn
  S3BucketName:
    Value: !Ref S3Bucket
  DashboardURL:
    Value: !GetAtt Collection.DashboardEndpoint
  AmazonBedrockExecutionRoleForKnowledgeBase:
    Value: !GetAtt AmazonBedrockExecutionRoleForKnowledgeBase.Arn
  CollectionARN:
    Value: !GetAtt Collection.Arn
  AOSSVectorIndexName:
    Description: vector index
    Value: !Ref AOSSIndexName
  Region:
    Description: Deployed Region
    Value: !Ref AWS::Region
  CreatedIndexName:
    Description: 'Name of the created vector index'
    Value: !Ref AOSSIndexName
  LambdaExecutionRoleArn:
    Description: 'ARN of the Lambda execution role'
    Value: !GetAtt LambdaExecutionRole.Arn
  DataAccessPolicyName:
    Description: 'Name of the created data access policy'
    Value: !Ref DataAccessPolicy
